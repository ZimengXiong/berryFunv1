# Session: 

**Session ID**: `d246dbe6-622c-4d1f-9b54-1680f3cb094f`

---

## User Prompts

### 1. 2026-02-01 08:03

I understand the architecture you are building. You are designing a state-based ledger system where registration is treated as a continuous financial document rather than a one-time checkout. The "Delta" logic ensures that if a user adds a fourth week later, the system calculates the 4-week discount tier, subtracts the 3-week discount already received, and applies that difference to the new balance.

Here is the high-fidelity professional plan and technical requirements for a senior developer to implement this system using Convex and React.

1. System Requirements
Functional Requirements
Persistent Draft State: Users must be able to add/remove sessions from a "Draft" ledger that persists across sessions (stored in Convex, not localStorage).

Floating Global Action: A UI element must monitor the draft count and provide a gateway to the checkout flow once the ledger is non-empty.

Blocking Consent Workflow: A sequential, state-driven modal system must gate the payment process.

Stage 1: General Liability.

Stage 2: Financial Terms (emphasizing the $50/week non-refundable deposit in high-contrast red).

Receipt Tracking: Support for multiple independent payment uploads (Zelle/Cash receipts) per user, which admins can verify to "lock" sessions.

Technical Requirements
Backend (Convex): Schema must support relational links between users, ledgerItems (sessions), and receipts. Mutations must be atomic to prevent state desync.

The Delta Engine: A server-side reactive query that calculates the current "Balance Due" by evaluating the entire summer's liability (Paid + Draft) and subtracting the verified historical payments.

Frontend (React): Use a state machine for modal management and optimistic updates for "Add to Ledger" actions to ensure a latency-free experience.

2. Technical Roadmap
Phase 1: Schema Architecture
Define the data model to handle identity-based and volume-based discounts.

Users Table: Include isReturning, siblingGroupId, and referralClaimed.

LedgerItems Table: Track status (draft | secured | verified), sessionID, and timestamp (for Early Bird eligibility).

Receipts Table: Link to Convex Storage IDs for payment verification.

Phase 2: The Multi-Week Discount Resolver
Implement the volume-based discount logic as a single source of truth.

Store the tier map (e.g., 3 weeks = $50, 11 weeks = $340).

Calculation Logic:

TotalCredit=Tier(N 
total
​
 )+(N 
total
​
 ×WeeklyCredits)
DeltaDue=(NewTuition−TotalCredit)−PaidAmount
This ensures that adding a week at any time automatically triggers the higher-tier discount for all previously paid weeks via a credit on the new balance.

Phase 3: Silent Enrollment & Floating UI
Refactor the catalog "Enroll" button to trigger a addToLedger mutation without navigation.

Implement a persistent Floating Action Button (FAB) that monitors the ledgerItems table for any records where status == 'draft'.

Phase 4: Verification & Snapshotting
Admin Workflow: Create a mutation that transitions secured items to verified after receipt review.

Snapshotting: On verification, store the applied discount values in the ledger record to protect against future changes to the global discount configuration.

3. High-Level Logic Constraints
The Deposit Rule: Every new session added requires a $50 deposit, even if the "Tier Delta" makes the net tuition increase smaller than $50.

Early Bird Lock: Eligibility is determined by the createdAt timestamp of the ledgerItem. If the draft was created before the deadline, the 5% discount persists even if payment happens later.

Referral Logic: Check a hasUsedReferral flag on the user profile to ensure the $20 credit is a one-time application for new students only.

Would you like me to refine the specific logic for handling "Session Removal" and how that affects previously paid deposits and tier-based credits?

how would you handle coupons and verification of payment? since our verification of payment is async (user submit screenshots, admins verify async). coupons are aplied single use to one person, that would ruin the state based logic?

To handle coupons and asynchronous verification within a state-based ledger, you must treat both as asynchronous ledger events rather than static price modifiers. This maintains the integrity of the "Delta" logic by ensuring the system always knows what has been "claimed" versus what has been "finalized."

1. Coupon Logic: The "Claim" vs. "Consumption" Model
To prevent a single-use coupon from breaking the state-based logic, you must decouple the coupon’s validity from the session price.

The Coupon Record: Create a coupons table that tracks code, discountValue, status (available, pending, consumed), and linkedUserId.

The Claim Mutation: When a user enters a code, the system creates a ledgerItem of type credit_memo. This item carries a negative balance (e.g., -$20) and is linked to the couponId.

State Locking: While the user has a "Draft" ledger, the coupon is marked as pending to the userId. It cannot be used by anyone else. If the user clears their draft without checking out, the coupon reverts to available.

Consumption: The coupon only moves to consumed once an Admin verifies the receipt associated with that ledger state. This prevents users from "gaming" the delta logic by applying a coupon, getting a discount, and then trying to reuse it on a subsequent week.

2. Async Payment Verification: The "Secured" Buffer
Since verification is asynchronous (screenshot-based), you need a transitionary state that protects the student's spot while acknowledging the funds aren't "in the bank" yet.

Three-Tier Status:

Draft: User is looking; no spot reserved.

Secured (Pending Verification): User has uploaded a screenshot. The system marks the session as "occupied" in the UI to prevent overbooking, but the "Delta Engine" treats the payment as an unverified credit.

Verified: Admin approves the screenshot. The ledgerItem is now "Locked."

The "Shadow Balance": The Ledger should display two totals:

Balance Due: What is owed right now to submit the next receipt.

Pending Approval: The sum of all submitted but unverified receipts.

3. Integrating Coupons into the Delta Engine
The Delta Engine must treat coupons as a "one-time global credit" rather than a "per-week discount."

The Calculation Sequence:

Calculate Gross Tuition: Sum of all verified and secured sessions.

Apply Tiered Multi-Week Discount: Based on the total count of (Verified + Secured).

Apply Per-Week Credits: (Returning Student/Sibling).

Subtract One-Time Credits: This is where the Coupon Ledger Item resides.

Subtract Total Paid: Only include verified payments.

Result: Current Liability.

4. Admin Verification Workflow
To handle the async nature efficiently, the Admin Dashboard requires a specific mutation flow:

Atomic Promotion: When an admin clicks "Verify," a single mutation must:

Update the receipt status to verified.

Update all ledgerItems associated with that receiptId from secured to verified.

Snapshot the final discount values onto those items.

Rejection Handling: If a receipt is "Denied" (e.g., blurry screenshot or incorrect amount), the ledgerItems must revert to draft or payment_required status, and the user receives an automated notification to re-upload. This prevents the "Delta" from permanently including a discount for a payment that never cleared.

5. Handling "Mid-Verification" Additions
If a user adds a week while a previous payment is still pending verification:

The system should assume the pending payment will be verified.

It calculates the "New Balance" as if the previous payment is valid.

However, it prevents the user from "Finalizing" the new week until the Admin has cleared the previous receipt, or it simply appends the new $50 deposit to the total "Amount to Pay" on the next receipt.

This approach ensures the state-based logic remains a continuous stream of financial truth, regardless of the delay in human verification.

describe big picture what we are trying to do

The big picture is the replacement of a traditional "checkout" model with a continuous, state-driven ledger.

In a standard e-commerce flow, once a user pays for three weeks of camp, that transaction is closed. If they later decide to add a fourth week, the system treats it as a new, isolated event. Our goal is to treat the entire summer as a single, evolving financial statement.

1. The Financial Source of Truth
Instead of a series of disconnected orders, we are building a system where the "Total Amount Due" is always a live calculation of:

Total Summer Liability: (All selected weeks × Base Rate) − (Cumulative Volume Discounts) − (Identity Discounts).

Net Balance: (Total Summer Liability) − (Sum of all previously Verified Payments).

This ensures that the "Multi-Week Discount" remains fair. If adding a 4th week bumps the user into a higher discount tier, the system automatically applies that retroactive credit toward the balance of the new week.

2. Trust-But-Verify Workflow
Since payments occur via Zelle or Cash, the system must handle a high degree of "pending" state. We are building a "Secured" buffer where:

The student's spot is reserved the moment a receipt is uploaded.

The financial logic assumes the payment is valid to keep the "Delta" calculation accurate for the user.

Admin verification acts as the final "lock," snapshotting the discounts and moving the funds from "Pending" to "Verified."

3. Frictionless Intent, Enforced Consent
The UI is designed to capture intent silently—adding weeks to a ledger without interrupting the browsing flow—while strictly enforcing financial boundaries at the point of commitment. The "Big Picture" UX ensures that by the time a user reaches the ledger, they have:

Selection: Aggregated their full summer plan.

Consent: Acknowledged the non-refundable $50/week deposit via high-contrast, multi-stage modals.

Transparency: Viewed a live breakdown of how their specific identity (Returning Student, Sibling) and volume (Tiered weeks) affect their final price.

4. Technical Resilience
We are leveraging Convex’s reactive nature to make this complex math feel instantaneous. Every time a user adds a week or an admin approves a receipt, the entire ledger recalculates globally. This eliminates the "state drift" common in systems that try to track discounts manually or through one-time coupon codes.

Would you like me to focus on the data schema required to keep this "Delta Engine" performant as the number of ledger items grows? build this, using react+convex

